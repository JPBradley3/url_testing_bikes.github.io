<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bicycle Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        :root {
            --bg-color: rgba(255, 255, 255, 0.75); /* Slightly more transparent white for light mode */
            --text-color: #2c3e50;
            --label-color: #666;
            --border-color: #e0e0e0;
            --hover-color: #2980b9;
        }

        [data-theme="dark"] {
            --bg-color: rgba(50, 50, 50, 0.75); /* Slightly more transparent dark background for dark mode */
            --text-color: #b0b0b0; /* Dimmer white text */
            --label-color: #909090; /* Dimmer label color */
            --border-color: #666666; /* Dimmer border color */
            --hover-color: #4a8bb5; /* Dimmer hover color */
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #map {
            width: 100%;
            height: 100vh;
            z-index: 1;
        }

        #info {
            position: absolute;
            background: var(--bg-color); /* Use the updated transparent background */
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            min-width: 240px;
            backdrop-filter: blur(5px); /* Add blur effect for better readability */
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Default position for portrait mode (bottom center) */
        #info {
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Landscape mode: position at the bottom left */
        @media (orientation: landscape) {
            #info {
                bottom: 15px;
                left: 15px;
                transform: none;
            }
        }

        #theme-toggle-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: 0.4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--hover-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        #neighborhood-title {
            margin: 0 0 10px 0; /* Reduced margin */
            font-size: 1.2em; /* Smaller font size */
            color: var(--text-color);
            text-align: center;
            border-bottom: 1px solid var(--border-color); /* Thinner border */
            padding-bottom: 8px; /* Reduced padding */
            transition: color 0.3s ease;
        }

        .data-container {
            display: flex;
            flex-direction: column;
            gap: 8px; /* Reduced gap */
        }

        .data-row {
            display: flex;
            align-items: center;
            gap: 8px; /* Reduced gap */
            font-size: 0.9em; /* Smaller font size */
        }

        .data-row label {
            color: var(--label-color);
            font-weight: 500;
            min-width: 120px; /* Reduced width */
            transition: color 0.3s ease;
        }

        #cross-streets {
            color: var(--text-color);
            font-weight: 600;
            transition: color 0.3s ease;
        }

        #speed {
            color: var(--text-color);
            font-weight: 700; /* Increased font weight */
            font-size: 1.5em; /* Larger font size for speed */
            min-width: 60px;
            text-align: right;
            transition: color 0.3s ease;
        }

        .unit {
            color: var(--label-color);
            font-size: 0.8em; /* Smaller font size for unit */
            transition: color 0.3s ease;
        }

        #start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 12px 25px; /* Reduced padding */
            font-size: 1em; /* Smaller font size */
            font-weight: 600;
            color: white;
            background-color: #3498db;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #start-button:hover {
            background-color: var(--hover-color);
            transform: translate(-50%, -50%) scale(1.05);
        }

        #start-button:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        @media (max-width: 600px) {
            #info {
                width: 90%; /* Adjusted width for smaller screens */
                padding: 8px; /* Reduced padding */
            }

            .data-row {
                font-size: 0.8em; /* Smaller font size for small screens */
            }

            #neighborhood-title {
                font-size: 1em; /* Smaller title font size */
            }
        }
    </style>
</head>
<body>
    <div id="info" style="display: none;">
        <div id="theme-toggle-container">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
        <h1 id="neighborhood-title">Loading Area...</h1>
        <div class="data-container">
            <div class="data-row">
                <label>Nearest Cross Streets:</label>
                <span id="cross-streets">Loading...</span>
            </div>
            <div class="data-row">
                <label>Speed:</label>
                <span id="speed">0</span>
                <span class="unit">mph</span>
            </div>
        </div>
    </div>
    <div id="map" style="display: none;"></div>
    <button id="start-button">Start Tracking</button>
    <button id="fullscreen-button">Go Fullscreen</button>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-rotatedmarker/0.2.0/leaflet.rotatedMarker.min.js"></script>
    <script>
        let lastPosition = null;
        let debounceTimer;
        let isMapInitialized = false;
        let lastRequestTime = 0;
        const MIN_REQUEST_INTERVAL = 1500; // 1.5 seconds minimum between requests
        const REQUEST_QUEUE = [];
        let isProcessingQueue = false;
        let lastUpdateTime = 0; // Track the last update time

        let currentSpeed = 0; // Speed in mph
        let lastAcceleration = { x: 0, y: 0, z: 0 };
        let lastAccelerationTime = Date.now();

        function handleDeviceMotion(event) {
            const acceleration = event.accelerationIncludingGravity;
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastAccelerationTime) / 1000; // Time in seconds

            if (deltaTime > 0) {
                // Calculate the change in acceleration
                const deltaX = acceleration.x - lastAcceleration.x;
                const deltaY = acceleration.y - lastAcceleration.y;
                const deltaZ = acceleration.z - lastAcceleration.z;

                // Calculate the magnitude of the acceleration vector
                const accelerationMagnitude = Math.sqrt(deltaX ** 2 + deltaY ** 2 + deltaZ ** 2);

                // Update the speed (v = u + at, where u is the initial speed, a is acceleration, t is time)
                currentSpeed += accelerationMagnitude * deltaTime * 2.23694; // Convert m/s to mph

                // Prevent negative speed
                currentSpeed = Math.max(0, currentSpeed);

                // Update the last acceleration and time
                lastAcceleration = { x: acceleration.x, y: acceleration.y, z: acceleration.z };
                lastAccelerationTime = currentTime;

                // Display the updated speed
                document.getElementById("speed").textContent = currentSpeed.toFixed(1);
            }
        }

        async function processRequestQueue() {
            if (isProcessingQueue || REQUEST_QUEUE.length === 0) return;

            isProcessingQueue = true;

            while (REQUEST_QUEUE.length > 0) {
                const { url, resolve, reject } = REQUEST_QUEUE[0];

                try {
                    const now = Date.now();
                    const timeToWait = Math.max(0, MIN_REQUEST_INTERVAL - (now - lastRequestTime));

                    if (timeToWait > 0) {
                        await new Promise(r => setTimeout(r, timeToWait));
                    }

                    const response = await fetch(url, {
                        headers: {
                            'User-Agent': 'BicycleTracker/1.0'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    lastRequestTime = Date.now();
                    resolve(data);

                } catch (error) {
                    reject(error);
                }

                REQUEST_QUEUE.shift();
            }

            isProcessingQueue = false;
        }

        function makeRequest(url) {
            return new Promise((resolve, reject) => {
                REQUEST_QUEUE.push({ url, resolve, reject });
                processRequestQueue().catch(error => {
                    console.error("Error processing request queue:", error);
                });
            });
        }

        function debounce(func, delay) {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(func, delay);
        }

        async function fetchCrossStreets(lat, lon) {
            const validRoadTypes = ["Ave", "St", "Blvd", "Hwy", "Rd", "Dr", "Ln", "Ct", "Pl", "Way", "Pkwy", "Cir", "Terrace", "Alley"];

            try {
                const reverseData = await makeRequest(
                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&addressdetails=1`
                );

                if (!reverseData || !reverseData.address) {
                    throw new Error("Invalid reverse geocoding response");
                }

                const neighborhood = reverseData.address.neighbourhood ||
                                     reverseData.address.suburb ||
                                     reverseData.address.district ||
                                     reverseData.address.city_district ||
                                     reverseData.address.city ||
                                     'Current Location';

                document.getElementById("neighborhood-title").textContent = neighborhood;

                const currentRoad = reverseData.address.road || "Unknown";

                if (currentRoad === "Unknown") {
                    document.getElementById("cross-streets").textContent = "Location unavailable";
                    return;
                }

                const delta = 0.002;
                const searchData = await makeRequest(
                    `https://nominatim.openstreetmap.org/search?` +
                    `format=json&` +
                    `street=${encodeURIComponent(currentRoad)}&` +
                    `viewbox=${lon - delta},${lat - delta},${lon + delta},${lat + delta}&` +
                    `bounded=1&` +
                    `addressdetails=1&` +
                    `limit=20`
                );

                const nearbyStreets = new Set();
                for (let place of searchData) {
                    if (place.address && place.address.road) {
                        const roadName = place.address.road;
                        if (roadName.toLowerCase() !== currentRoad.toLowerCase()) {
                            if (validRoadTypes.some(type =>
                                roadName.toLowerCase().includes(type.toLowerCase()) ||
                                currentRoad.toLowerCase().includes(type.toLowerCase())
                            )) {
                                nearbyStreets.add(roadName);
                            }
                        }
                    }
                }

                if (nearbyStreets.size > 0) {
                    const nearestStreet = Array.from(nearbyStreets)[0];
                    document.getElementById("cross-streets").textContent =
                        `${currentRoad} & ${nearestStreet}`;
                } else {
                    document.getElementById("cross-streets").textContent =
                        `${currentRoad} (No intersection found)`;
                }

            } catch (error) {
                console.error("Error fetching location data:", error);
                document.getElementById("cross-streets").textContent = "Location unavailable";
                document.getElementById("neighborhood-title").textContent = "Current Location";
            }
        }

        function loadMap() {
            console.log("Initializing map...");
            window.map = L.map('map', { zoomControl: false, attributionControl: false });
            console.log("Map initialized:", window.map);

            const lightTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '' // Remove attribution
            });

            const darkTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '', // Remove attribution
                subdomains: 'abcd',
                maxZoom: 19
            });

            lightTileLayer.addTo(window.map);
            window.tileLayers = { light: lightTileLayer, dark: darkTileLayer };

            window.marker = L.marker([0, 0]).addTo(window.map);
            console.log("Marker added to map.");

            const geoJsonData = {
                "type": "FeatureCollection",
                "features": [
                    {
                        "type": "Feature",
                        "geometry": {
                            "type": "LineString",
                            "coordinates": [
                                [-122.4194, 37.7749],
                                [-122.4094, 37.7849],
                                [-122.3994, 37.7949]
                            ]
                        },
                        "properties": {}
                    }
                ]
            };

            window.geoJsonLayer = L.geoJSON(geoJsonData, {
                style: {
                    color: 'blue', // Default color for light mode
                    weight: 4
                }
            }).addTo(window.map);

            isMapInitialized = true;
        }

        function updateLocation(position) {
            if (!isMapInitialized) {
                console.error("Map is not initialized yet.");
                return;
            }

            const currentTime = Date.now();
            const timeSinceLastUpdate = currentTime - lastUpdateTime;

            // Only process updates if at least 2 seconds have passed
            if (timeSinceLastUpdate < 2000) {
                return;
            }

            lastUpdateTime = currentTime; // Update the last update time

            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            const gpsSpeed = position.coords.speed ? position.coords.speed * 2.23694 : 0; // Convert m/s to mph
            const heading = position.coords.heading;

            // Combine GPS speed and accelerometer speed for better accuracy
            const combinedSpeed = gpsSpeed > 0 ? gpsSpeed : currentSpeed;

            console.log(`Latitude: ${lat}, Longitude: ${lon}, Speed: ${combinedSpeed}, Heading: ${heading}`);

            document.getElementById("speed").textContent = combinedSpeed.toFixed(1);

            document.getElementById("map").style.display = "block";
            window.map.setView([lat, lon], 19);
            window.marker.setLatLng([lat, lon]);

            if (heading !== null && !isNaN(heading)) {
                window.marker.setRotationAngle(heading);
            } else {
                console.warn("Heading is unavailable. Marker rotation will not update.");
            }

            if (!lastPosition || 
                Math.abs(lastPosition.lat - lat) > 0.0001 || 
                Math.abs(lastPosition.lon - lon) > 0.0001) {
                lastPosition = { lat, lon };
                debounce(() => fetchCrossStreets(lat, lon), 2000);
            }
        }

        function showError(error) {
            console.error("Error getting location:", error);
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    alert("Location access denied by the user.");
                    break;
                case error.POSITION_UNAVAILABLE:
                    alert("Location information is unavailable.");
                    break;
                case error.TIMEOUT:
                    alert("The request to get your location timed out.");
                    break;
                default:
                    alert("An unknown error occurred.");
                    break;
            }
        }

        document.getElementById("theme-toggle").addEventListener("change", (event) => {
            const html = document.documentElement;
            const newTheme = event.target.checked ? "dark" : "light";
            html.setAttribute("data-theme", newTheme);
            localStorage.setItem("theme", newTheme);

            if (window.map && window.tileLayers) {
                if (newTheme === "dark") {
                    window.map.removeLayer(window.tileLayers.light);
                    window.tileLayers.dark.addTo(window.map);

                    // Brighten GeoJSON layer in dark mode
                    if (window.geoJsonLayer) {
                        window.geoJsonLayer.setStyle({ color: '#ffffff', weight: 5 }); // Brighter white and thicker lines
                    }
                } else {
                    window.map.removeLayer(window.tileLayers.dark);
                    window.tileLayers.light.addTo(window.map);

                    // Reset GeoJSON layer to default in light mode
                    if (window.geoJsonLayer) {
                        window.geoJsonLayer.setStyle({ color: 'blue', weight: 4 });
                    }
                }
            }
        });

        document.addEventListener("DOMContentLoaded", () => {
            const savedTheme = localStorage.getItem("theme") || "light";
            document.documentElement.setAttribute("data-theme", savedTheme);
            document.getElementById("theme-toggle").checked = savedTheme === "dark";

            if (window.map && window.tileLayers) {
                if (savedTheme === "dark") {
                    window.tileLayers.dark.addTo(window.map);
                } else {
                    window.tileLayers.light.addTo(window.map);
                }
            }
        });

        function startTracking() {
            document.getElementById("start-button").style.display = "none";
            document.getElementById("map").style.display = "block";
            document.getElementById("info").style.display = "block";

            loadMap();

            const geoOptions = {
                enableHighAccuracy: true, // Request high accuracy mode
                maximumAge: 0,           // Do not use cached location data
                timeout: 10000           // Wait up to 10 seconds for a location fix
            };

            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(updateLocation, showError, geoOptions);
            } else {
                alert("Geolocation is not supported by your browser.");
            }

            // Start listening for accelerometer data
            if (window.DeviceMotionEvent) {
                window.addEventListener("devicemotion", handleDeviceMotion);
            } else {
                console.warn("DeviceMotionEvent is not supported on this device.");
            }
        }

        document.getElementById("start-button").addEventListener("click", startTracking);

        document.getElementById("fullscreen-button").addEventListener("click", () => {
            const element = document.documentElement; // Fullscreen the entire page

            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) { // For Safari
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) { // For older IE/Edge
                element.msRequestFullscreen();
            }
        });

        document.addEventListener("fullscreenchange", () => {
            if (!document.fullscreenElement) {
                console.log("Exited fullscreen mode");
            }
        });
    </script>
</body>
</html>

